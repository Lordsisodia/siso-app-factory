import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useState, useRef, useId } from "react";
import { useController } from "react-hook-form";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { useUser } from "@clerk/nextjs";
import { makeSlugFromName, useIsCheckSlugAvailable, } from "../../hooks/use-is-check-slug-available";
import { usePrefillAutogeneratedSlug } from "../../hooks/use-name-slug-form";
export function NameSlugForm({ form, publishAsUserId, isSlugReadOnly, placeholderName, }) {
    const { user: currentUser } = useUser();
    const [isSlugManuallyEdited, setIsSlugManuallyEdited] = useState(false);
    const slug = form.watch("component_slug");
    const userId = publishAsUserId ?? currentUser?.id;
    const nameInputRef = useRef(null);
    const nameId = useId();
    const slugId = useId();
    const { isAvailable: slugAvailable, isChecking: isSlugChecking, error: slugError, } = useIsCheckSlugAvailable({
        slug,
        type: "component",
        userId: userId ?? "",
        enabled: !isSlugReadOnly,
    });
    if (slugAvailable !== undefined &&
        form.getValues("slug_available") !== slugAvailable) {
        form.setValue("slug_available", slugAvailable);
    }
    usePrefillAutogeneratedSlug({
        form,
        isSlugReadOnly,
        isSlugManuallyEdited,
        publishAsUserId: userId,
    });
    const { field: nameField } = useController({
        name: "name",
        control: form.control,
        rules: { required: true },
    });
    return (_jsxs("div", { className: "flex flex-col w-full", children: [_jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsxs(Label, { htmlFor: nameId, children: ["Name ", _jsx("span", { className: "text-destructive", children: "*" })] }), _jsx(Input, { id: nameId, ref: (e) => {
                                    nameField.ref(e);
                                    nameInputRef.current = e;
                                }, placeholder: `e.g. "${placeholderName.replace(/([a-z])([A-Z])/g, "$1 $2")}"`, value: nameField.value, onChange: nameField.onChange, onBlur: nameField.onBlur, className: "w-full text-foreground", required: true }), _jsx("p", { className: "text-xs text-muted-foreground", role: "region", "aria-live": "polite", children: "The display name of your component" })] }), _jsxs("div", { className: "space-y-2", children: [_jsxs(Label, { htmlFor: slugId, children: ["Slug ", _jsx("span", { className: "text-destructive", children: "*" })] }), _jsx(Input, { id: slugId, ...form.register("component_slug", { required: true }), className: "w-full", placeholder: `e.g. "${makeSlugFromName(placeholderName)}"`, disabled: isSlugReadOnly || (isSlugChecking && !isSlugManuallyEdited), onChange: (e) => {
                                    setIsSlugManuallyEdited(true);
                                    form.setValue("component_slug", e.target.value);
                                }, required: true }), _jsx("p", { className: "text-xs text-muted-foreground", role: "region", "aria-live": "polite", children: "Used in the URL and imports, can't be changed later" })] })] }), slugError && (_jsx("p", { className: "text-red-500 text-sm mt-2", children: slugError.message })), slug?.length > 0 && !slugError && isSlugManuallyEdited && (_jsx(_Fragment, { children: isSlugChecking ? (_jsx("p", { className: "text-muted-foreground text-sm mt-2", children: "Checking slug availability..." })) : slugAvailable === true ? (_jsx("p", { className: "text-green-500 text-sm mt-2", children: "This slug is available" })) : (_jsx("p", { className: "text-red-500 text-sm mt-2", children: "You already have a component with this slug" })) }))] }));
}
//# sourceMappingURL=component.js.map